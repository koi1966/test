!!!!!!!!!!!!!!!!!!
Для чего в Java используются статические блоки инициализации?

Статические блоки инициализация используются для выполнения кода, который должен
выполняться один раз при инициализации класса загрузчиком классов, в момент,
предшествующий созданию объектов этого класса при помощи конструктора.
Такой блок (в отличие от нестатических, принадлежащих конкретном объекту класса)
принадлежит только самому классу (объекту метакласса Class).

!!!!!!!!!!!!!!!!!!
Что произойдёт, если в блоке инициализации возникнет исключительная ситуация?

Для нестатических блоков инициализации, если выбрасывание исключения прописано явным
образом требуется, чтобы объявления этих исключений были перечислены в throws всех
конструкторов класса. Иначе будет ошибка компиляции. Для статического блока выбрасывание
исключения в явном виде, приводит к ошибке компиляции.

В остальных случаях, взаимодействие с исключениями будет проходить так же, как и в
любом другом месте. Класс не будет инициализирован, если ошибка происходит в статическом
блоке и объект класса не будет создан, если ошибка возникает в нестатическом блоке.

!!!!!!!!!!!!!!!!!!
Как получить доступ к переопределенным методам родительского класса?

С помощью ключевого слова super мы можем обратиться к любому члену родительского
класса - методу или полю, если они не определены с модификатором private.

super.method();


!!!!!!!!!!!!!!!!!!
Какие типы классов бывают в java?

• Top level class (Обычный класс):
        ○ Abstract class (Абстрактный класс);
        ○ Final class (Финализированный класс).
• Interfaces (Интерфейс).
• Enum (Перечисление).
• Nested class (Вложенный класс):
       ○ Static nested class (Статический вложенный класс);
       ○ Member inner class (Простой внутренний класс);
       ○ Local inner class (Локальный класс);
       ○ Anonymous inner class (Анонимный класс).

!!!!!!!!!!!!!!!!!!

Расскажите про вложенные классы. В каких случаях они применяются?

Класс называется вложенным (Nested class), если он определен внутри другого класса.
Вложенный класс должен создаваться только для того, чтобы обслуживать обрамляющий его класс.
Если вложенный класс оказывается полезен в каком-либо ином контексте, он должен стать классом
верхнего уровня. Вложенные классы имеют доступ ко всем (в том числе приватным) полям и методам
внешнего класса, но не наоборот. Из-за этого разрешения использование вложенных классов приводит
к некоторому нарушению инкапсуляции.

Существуют четыре категории вложенных классов:
• Static nested class (Статический вложенный класс);
• Member inner class (Простой внутренний класс);
• Local inner class (Локальный класс);
• Anonymous inner class (Анонимный класс).
Такие категории классов, за исключением первого, также называют внутренними (Inner class).
Внутренние классы ассоциируются не с внешним классом, а с экземпляром внешнего.

Каждая из категорий имеет рекомендации по своему применению. Если вложенный класс должен
быть виден за пределами одного метода или он слишком длинный для того, чтобы его можно было
удобно разместить в границах одного метода и если каждому экземпляру такого класса необходима
ссылка на включающий его экземпляр, то используется нестатический внутренний класс. В случае,
если ссылка на обрамляющий класс не требуется - лучше сделать такой класс статическим.
Если класс необходим только внутри какого-то метода и требуется создавать экземпляры этого
класса только в этом методе, то используется локальный класс. А, если к тому же применение
класса сводится к использованию лишь в одном месте и уже существует тип, характеризующий
этот класс, то рекомендуется делать его анонимным классом.

!!!!!!!!!!!!!!!!!!

Каким образом из вложенного класса получить доступ к полю внешнего класса?

Статический вложенный класс имеет прямой доступ только к
статическим полям обрамляющего класса.

Простой внутренний класс, может обратиться к любому полю внешнего класса напрямую.
В случае, если у вложенного класса уже существует поле с таким же литералом,
то обращаться к такому полю следует через ссылку на его экземпляр.
Например: Outer.this.field.

!!!!!!!!!!!!!!!!!!

Каким образом из вложенного класса получить доступ к полю внешнего класса?

Статический вложенный класс имеет прямой доступ только к статическим полям..

!!!!!!!!!!!!!!!!!!

Как работает сборщик мусора?

Механизм сборки мусора - это процесс освобождения места в куче, для возможности добавления новых
объектов. Объекты создаются посредством оператора new, тем самым присваивая объекту ссылку.
Для окончания работы с объектом достаточно просто перестать на него ссылаться, например, присвоив
переменной ссылку на другой объект или значение null; прекратить выполнение метода, чтобы его
локальные переменные завершили свое существование естественным образом. Объекты, ссылки на
которые отсутствуют, принято называть мусором (garbage), который будет удален.

Виртуальная машина Java, применяя механизм сборки мусора, гарантирует, что любой объект,
обладающий ссылками, остается в памяти — все объекты, которые недостижимы из исполняемого
кода, ввиду отсутствия ссылок на них, удаляются с высвобождением отведенной для них памяти.
Точнее говоря, объект не попадает в сферу действия процесса сборки мусора, если он достижим
посредством цепочки ссылок, начиная с корневой (GC Root) ссылки, т.е. ссылки, непосредственно
существующей в выполняемом коде.

Память освобождается сборщиком мусора по его собственному «усмотрению». Программа может успешно
завершить работу, не исчерпав ресурсов свободной памяти или даже не приблизившись к этой черте
и поэтому ей так и не потребуются «услуги» сборщика мусора.

Мусор собирается системой автоматически, без вмешательства пользователя или программиста,
но это не значит, что этот процесс не требует внимания вовсе. Необходимость создания и
удаления большого количества объектов существенным образом сказывается на производительности
приложений и, если быстродействие программы является важным фактором, следует тщательно
обдумывать решения, связанные с созданием объектов, — это, в свою очередь, уменьшит и объем
мусора, подлежащего утилизации.

!!!!!!!!!!!!!!!!!!

