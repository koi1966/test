Анонимные классы

Инкапсуляция - скрытие реализации методов- private - переменніе через гетеры/сетеры

Фнкциональный интерфейс




Спасибо, что присоединились к моей сети контактов!
Нахожусь в поиске Junior Java Developer вакансии.
Буду рад сотрудничеству.

Пять основных принципов дизайна классов (S.O.L.I.D.) в Java

Классы — это блоки, из которых строится приложение. Так же, как кирпичи в здании.
Плохо написанные классы однажды могут принести проблемы.

Вот что входит в принципы SOLID:
Single Responsibility Principle (Принцип единственной ответственности).
На каждый объект возлагается одна обязанность, полностью инкапсулированная в класс.
Все сервисы класса направлены на обеспечение этой обязанности.

Open Closed Principle (Принцип открытости/закрытости).
Этот принцип емко описывают так: программные сущности (классы, модули, функции и т.п.) должны
быть открыты для расширения, но закрыты для изменения.

Liskov’s Substitution Principle (Принцип подстановки Барбары Лисков).
Это вариация принципа открытости/закрытости, о котором говорилось ранее.
Его можно описать так: объекты в программе можно заменить их наследниками без изменения свойств программы.
Это означает, что класс, разработанный путем расширения на основании базового класса, должен переопределять
его методы так, чтобы не нарушалась функциональность с точки зрения клиента. То есть, если разработчик расширяет
ваш класс и использует его в приложении, он не должен изменять ожидаемое поведение переопределенных методов.

Interface Segregation Principle (Принцип разделения интерфейса).
Характеризуется следующим утверждением: клиенты не должны быть вынуждены реализовывать методы,
которые они не будут использовать.

Dependency Inversion Principle (Принцип инверсии зависимостей).
Этот принцип SOLID в Java описывают так: зависимости внутри системы строятся на основе абстракций.
Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей.
Детали должны зависеть от абстракций.

Программное обеспечение нужно разрабатывать так, чтобы различные модули были автономными и соединялись
друг с другом с помощью абстракции.


!!!!!!!!!!!!!!!!!!
Для чего в Java используются статические блоки инициализации?

Статические блоки инициализация используются для выполнения кода, который должен
выполняться один раз при инициализации класса загрузчиком классов, в момент,
предшествующий созданию объектов этого класса при помощи конструктора.
Такой блок (в отличие от нестатических, принадлежащих конкретном объекту класса)
принадлежит только самому классу (объекту метакласса Class).

!!!!!!!!!!!!!!!!!!
Что произойдёт, если в блоке инициализации возникнет исключительная ситуация?

Для нестатических блоков инициализации, если выбрасывание исключения прописано явным
образом требуется, чтобы объявления этих исключений были перечислены в throws всех
конструкторов класса. Иначе будет ошибка компиляции. Для статического блока выбрасывание
исключения в явном виде, приводит к ошибке компиляции.

В остальных случаях, взаимодействие с исключениями будет проходить так же, как и в
любом другом месте. Класс не будет инициализирован, если ошибка происходит в статическом
блоке и объект класса не будет создан, если ошибка возникает в нестатическом блоке.

!!!!!!!!!!!!!!!!!!
Как получить доступ к переопределенным методам родительского класса?

С помощью ключевого слова super мы можем обратиться к любому члену родительского
класса - методу или полю, если они не определены с модификатором private.

super.method();


!!!!!!!!!!!!!!!!!!
Какие типы классов бывают в java?

• Top level class (Обычный класс):
        ○ Abstract class (Абстрактный класс);
        ○ Final class (Финализированный класс).
• Interfaces (Интерфейс).
• Enum (Перечисление).
• Nested class (Вложенный класс):
       ○ Static nested class (Статический вложенный класс);
       ○ Member inner class (Простой внутренний класс);
       ○ Local inner class (Локальный класс);
       ○ Anonymous inner class (Анонимный класс).
!!!!!!!!!!!!!!!!!!
Расскажите про вложенные классы. В каких случаях они применяются?

Класс называется вложенным (Nested class), если он определен внутри другого класса.
Вложенный класс должен создаваться только для того, чтобы обслуживать обрамляющий его класс.
Если вложенный класс оказывается полезен в каком-либо ином контексте, он должен стать классом
верхнего уровня. Вложенные классы имеют доступ ко всем (в том числе приватным) полям и методам
внешнего класса, но не наоборот. Из-за этого разрешения использование вложенных классов приводит
к некоторому нарушению инкапсуляции.

Существуют четыре категории вложенных классов:
• Static nested class (Статический вложенный класс);
• Member inner class (Простой внутренний класс);
• Local inner class (Локальный класс);
• Anonymous inner class (Анонимный класс).
Такие категории классов, за исключением первого, также называют внутренними (Inner class).
Внутренние классы ассоциируются не с внешним классом, а с экземпляром внешнего.

Каждая из категорий имеет рекомендации по своему применению. Если вложенный класс должен
быть виден за пределами одного метода или он слишком длинный для того, чтобы его можно было
удобно разместить в границах одного метода и если каждому экземпляру такого класса необходима
ссылка на включающий его экземпляр, то используется нестатический внутренний класс. В случае,
если ссылка на обрамляющий класс не требуется - лучше сделать такой класс статическим.
Если класс необходим только внутри какого-то метода и требуется создавать экземпляры этого
класса только в этом методе, то используется локальный класс. А, если к тому же применение
класса сводится к использованию лишь в одном месте и уже существует тип, характеризующий
этот класс, то рекомендуется делать его анонимным классом.

!!!!!!!!!!!!!!!!!!
Что такое «анонимные классы»? Где они применяются?

Это вложенный локальный класс без имени, который разрешено декларировать в любом месте
обрамляющего класса, разрешающем размещение выражений. Создание экземпляра анонимного
класса происходит одновременно с его объявлением.
В зависимости от местоположения анонимный класс ведет себя как статический либо как
нестатический вложенный класс - в нестатическом контексте появляется окружающий его экземпляр.

Анонимные классы имеют несколько ограничений:

• Их использование разрешено только в одном месте программы - месте его создания;
• Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться;
• Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо
новых методов, так как для доступа к ним нет поименованного типа.

Анонимные классы обычно применяются для:

• создания объекта функции (function object), например, реализация интерфейса Comparator;
• создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных;
• в статическом методе генерации;
• инициализации открытого статического поля final, которое соответствует сложному перечислению типов,
когда для каждого экземпляра в перечислении требуется отдельный подкласс.

String   !!!!!!!!!!!!!!!!!!  String
Что такое «пул строк»?

Пул строк – это набор строк, хранящийся в Heap.

• Пул строк возможен благодаря неизменяемости строк в Java и реализации идеи интернирования строк;
• Пул строк помогает экономить память, но по этой же причине создание строки занимает больше времени;
• Когда для создания строки используются ", то сначала ищется строка в пуле с таким же значением, если находится,
    то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка на неё;
• При использовании оператора new создаётся новый объект String. Затем при помощи метода intern() эту строку
    можно поместить в пул или же получить из пула ссылку на другой объект String с таким же значением;
• Пул строк является примером паттерна «Приспособленец» (Flyweight).

!!!!!!!!!!!!!!!!!!!!!!!!!
Что делает метод intern() в классе String?

Метод intern() используется для сохранения строки в пуле строк или получения ссылки,
если такая строка уже находится в пуле.
!!!!!!!!!!!!!!!!!!!!!!!!!

1) абстрактный класс = что-то базовое и большое, мы должны реализовать ВСЕ абстрактные методы, это удобно когда под
этот класс попадают все или почти все сущности (например создаем машины, а в абстрактном классе есть абстрактные методы
wheels, maxSpeed, doors, color, name и все машины имеют эти аттрибуты, т.е. реализовать все абстрактные методы ЕСТЬ смысл)
2) Интерфейсы = куски описания, которые не всегда пересекаются и их можно комбинировать, например нам нужно описать
компьютер. Нет смысла все тулить в абстрактный класс, ведь компьютера бывают разные: ноутбук, домашний ПК, сервер,
compute stick. И объекты будут иметь поля: внешний блок питания (большой ПК / сервер), Адаптер питания (ноутбук,
маленький компьютер), монитор, встроенный дисплей (ноутбук), DVD-привод (у compute stick нет вообще такого) и т.д.,
то есть нет смысла все это пихать в абстрактный класс и потом при желании создать объект ноутбука переопределять
ненужные методы типо внешнего дисплея, внешнего блока питания и большого корпуса, т.к. это ноутбук и там попросту
этого нет. А вместо этого можно реализовать по отдельности интерфейсы ноутбук, домашний ПК, сервер, compute stick,
которые уже будут иметь только НУЖНЫЕ методы.

хочу уточнить и добавить: " а в абстрактном классе есть абстрактные методы wheels, maxSpeed, doors, color, name "
- это поля, а не методы. Методы обозначают действие и описываются глаголами (run, go, eat, ride etc).
Еще важная разница между абстрактными классами и интерфейсами: интерфейсы не могут иметь полей,
а абстрактные классы могут, как и любые классы. Классы как абстрактные так и нет именуются существительным
(wheels, maxSpeed, doors, color, name), а интерфейсы прилагетельными, которые указывают на умение или возможность
действия(eatable, ableToGo, runable, shotable etc)...

!!!!!!!!!!!!!!!!!!!!!!!!!!!