Вопросы/примеры на собеседовании
https://proglib.io/p/15-questions-for-programmers

Основные принципы ООП: абстракция, инкапсуляция, наследование, полиморфизм.

Абстрагирование - это отделение существенного от несущественного.
От Абстрактного метода нельзя создавать обекты - только наследоваться.
Абстракция —  означает выделение значимой информации и исключение из рассмотрения незначимой. С точки зрения
программирования это правильное разделение программы на объекты. Абстракция позволяет отобрать главные характеристики
и опустить второстепенные.

Пример: описание должностей в компании. Здесь название должности значимая информация, а описание обязанностей у каждой
должности это второстепенная информация. К примеру главной характеристикой для «директор» будет то, что это должность
чем-то управляет, а чем именно (директор по персоналу, финансовый директор, исполнительный директор) это уже
второстепенная информация.

Инкапсуляция — (гетеры / сетеры ) - скрытое работы внутренних действий.. от внешнего..

свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе.
Для Java корректно будет говорить, что инкапсуляция это «сокрытие реализации». Пример из жизни — пульт от телевизора.
Мы нажимаем кнопочку «увеличить громкость» и она увеличивается, но в этот момент происходят десятки процессов, которые
скрыты от нас.
Для Java: можно создать класс с 10 методами,
например вычисляющие площадь сложной фигуры, но сделать из них 9 private. 10й метод будет называться
«вычислитьПлощадь()» и объявлен public, а в нем уже будут вызываться необходимые скрытые от пользователя методы.
Именно его и будет вызывать пользователь.

Наследование — свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью
заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским или
суперклассом. Новый класс — потомком, наследником, дочерним или производным классом.

Полиморфизм — способность метода обрабатывать данные разних типов.

свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней
структуре объекта.
Пример (чуть переделанный) из Thinking in Java:

public interface Shape {
    void draw();
    void erase();
}
public class Circle implements Shape {
    public void draw() {
        System.out.println("Circle.draw()");
    }
}
public class Triangle implements Shape {
    public void draw() {
        System.out.println("Triangle.draw()");
    }
}

public class TestPol {

    public static void main(String[] args) {
        Shape shape1 = new Circle();
        Shape shape2 = new Triangle();
        testPoly(shape1);
        testPoly(shape2);
    }

    public static void testPoly(Shape shape) {
        shape.draw();
    }
}
//Вывод в консоль:
//Circle.draw()
//Triangle.draw()

Есть общий интерфейс «Фигура» и две его реализации «Треугольник» и «Круг». У каждого есть метод «нарисовать».
Благодаря полиморфизму нам нет нужды писать отдельный метод для каждой из множества фигур, чтобы вызвать метод
«нарисовать».  Вызов полиморфного метода позволяет одному типу выразить свое отличие от другого, сходного типа,
хотя они и происходят от одного базового типа. Это отличие выражается различным действием методов, вызываемых
через базовый класс (или интерфейс).
Здесь приведен пример полиморфизма (также называемый динамическим связыванием, или поздним связыванием, или
связыванием во время выполнения), в котором продемонстрировано как во время выполнения программы будет выполнен
тот метод, который принадлежит передаваемому объекту.



Какие существуют модификаторы доступа?

private (приватный): члены класса доступны только внутри класса. Для обозначения используется служебное слово private.

default, package-private, package level (доступ на уровне пакета): видимость класса/членов класса только внутри пакета.
   Является модификатором доступа по умолчанию - специальное обозначение не требуется.

protected (защищённый): члены класса доступны внутри пакета и в наследниках. Для обозначения используется служебное слово protected.

public (публичный): класс/члены класса доступны всем. Для обозначения используется служебное слово public.

Последовательность модификаторов по возрастанию уровня закрытости: public, protected, default, private.

Во время наследования возможно изменения модификаторов доступа в сторону большей видимости (для поддержания соответствия
принципу подстановки Барбары Лисков).

Дайте определение понятию «конструктор»

Конструктор — это специальный метод, у которого отсутствует возвращаемый тип и который имеет то же имя,
что и класс, в котором он используется. Конструктор вызывается при создании нового объекта класса и определяет
действия необходимые для его инициализации.



Тернарный оператор выбора (также известный как условный оператор) - это оператор в языке программирования,
который позволяет сократить запись простого условного выражения if-else в более компактную форму.

условие ? выражение1 : выражение2

Он состоит из трех частей:

условие: выражение, которое проверяется на истинность или ложность.
выражение1: значение, которое возвращается, если условие истинно.
выражение2: значение, которое возвращается, если условие ложно.

Как работает тернарный оператор выбора:

Если условие истинно, то возвращается значение выражения1.
Если условие ложно, то возвращается значение выражения2.

int a = 10;
int b = 5;

int max = (a > b) ? a : b;
System.out.println("Максимальное значение: " + max);

В этом примере, если a больше b, то переменной max будет присвоено значение a, иначе ей будет присвоено значение b.
Результат будет выведен на экран.

Тернарный оператор выбора - это удобный способ сократить код и делает его более читабельным,
когда условие и результаты являются простыми выражениями.


Анонимные классы
Инкапсуляция
Функциональный интерфейс

Пять основных принципов дизайна классов (S.O.L.I.D.) в Java

Классы — это блоки, из которых строится приложение. Так же, как кирпичи в здании.
Плохо написанные классы однажды могут принести проблемы.

Вот что входит в принципы SOLID:

 (Принцип единственной ответственности).
На каждый объект возлагается одна обязанность, полностью инкапсулированная в класс.
Все сервисы класса направлены на обеспечение этой обязанности.

Open Closed Principle (Принцип открытости/закрытости).
Этот принцип емко описывают так: программные сущности (классы, модули, функции и т.п.) должны
быть открыты для расширения, но закрыты для изменения.

Liskov’s Substitution Principle (Принцип подстановки Барбары Лисков).
Это вариация принципа открытости/закрытости, о котором говорилось ранее.
Его можно описать так: объекты в программе можно заменить их наследниками без изменения свойств программы.
Это означает, что класс, разработанный путем расширения на основании базового класса, должен переопределять
его методы так, чтобы не нарушалась функциональность с точки зрения клиента. То есть, если разработчик расширяет
ваш класс и использует его в приложении, он не должен изменять ожидаемое поведение переопределенных методов.

Interface Segregation Principle (Принцип разделения интерфейса).
Характеризуется следующим утверждением: клиенты не должны быть вынуждены реализовывать методы,
которые они не будут использовать.

Dependency Inversion Principle (Принцип инверсии зависимостей).
Этот принцип SOLID в Java описывают так: зависимости внутри системы строятся на основе абстракций.
Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей.
Детали должны зависеть от абстракций.

Программное обеспечение нужно разрабатывать так, чтобы различные модули были автономными и соединялись
друг с другом с помощью абстракции.


!!!!!!!!!!!!!!!!!!
Для чего в Java используются статические блоки инициализации?

Статические блоки инициализация используются для выполнения кода, который должен
выполняться один раз при инициализации класса загрузчиком классов, в момент,
предшествующий созданию объектов этого класса при помощи конструктора.
Такой блок (в отличие от нестатических, принадлежащих конкретном объекту класса)
принадлежит только самому классу (объекту метакласса Class).

!!!!!!!!!!!!!!!!!!
Что произойдёт, если в блоке инициализации возникнет исключительная ситуация?

Для нестатических блоков инициализации, если выбрасывание исключения прописано явным
образом требуется, чтобы объявления этих исключений были перечислены в throws всех
конструкторов класса. Иначе будет ошибка компиляции. Для статического блока выбрасывание
исключения в явном виде, приводит к ошибке компиляции.

В остальных случаях, взаимодействие с исключениями будет проходить так же, как и в
любом другом месте. Класс не будет инициализирован, если ошибка происходит в статическом
блоке и объект класса не будет создан, если ошибка возникает в нестатическом блоке.

!!!!!!!!!!!!!!!!!!
Как получить доступ к переопределенным методам родительского класса?

С помощью ключевого слова super мы можем обратиться к любому члену родительского
класса - методу или полю, если они не определены с модификатором private.

super.method();


!!!!!!!!!!!!!!!!!!
Какие типы классов бывают в java?

• Top level class (Обычный класс):
        ○ Abstract class (Абстрактный класс);
        ○ Final class (Финализированный класс).
• Interfaces (Интерфейс).
• Enum (Перечисление).
• Nested class (Вложенный класс):
       ○ Static nested class (Статический вложенный класс);
       ○ Member inner class (Простой внутренний класс);
       ○ Local inner class (Локальный класс);
       ○ Anonymous inner class (Анонимный класс).
!!!!!!!!!!!!!!!!!!
Расскажите про вложенные классы. В каких случаях они применяются?

Класс называется вложенным (Nested class), если он определен внутри другого класса.
Вложенный класс должен создаваться только для того, чтобы обслуживать обрамляющий его класс.
Если вложенный класс оказывается полезен в каком-либо ином контексте, он должен стать классом
верхнего уровня. Вложенные классы имеют доступ ко всем (в том числе приватным) полям и методам
внешнего класса, но не наоборот. Из-за этого разрешения использование вложенных классов приводит
к некоторому нарушению инкапсуляции.

Существуют четыре категории вложенных классов:
• Static nested class (Статический вложенный класс);
• Member inner class (Простой внутренний класс);
• Local inner class (Локальный класс);
• Anonymous inner class (Анонимный класс).
Такие категории классов, за исключением первого, также называют внутренними (Inner class).
Внутренние классы ассоциируются не с внешним классом, а с экземпляром внешнего.

Каждая из категорий имеет рекомендации по своему применению. Если вложенный класс должен
быть виден за пределами одного метода или он слишком длинный для того, чтобы его можно было
удобно разместить в границах одного метода и если каждому экземпляру такого класса необходима
ссылка на включающий его экземпляр, то используется нестатический внутренний класс. В случае,
если ссылка на обрамляющий класс не требуется - лучше сделать такой класс статическим.
Если класс необходим только внутри какого-то метода и требуется создавать экземпляры этого
класса только в этом методе, то используется локальный класс. А, если к тому же применение
класса сводится к использованию лишь в одном месте и уже существует тип, характеризующий
этот класс, то рекомендуется делать его анонимным классом.

!!!!!!!!!!!!!!!!!!
Что такое «анонимные классы»? Где они применяются?

Это вложенный локальный класс без имени, который разрешено декларировать в любом месте
обрамляющего класса, разрешающем размещение выражений. Создание экземпляра анонимного
класса происходит одновременно с его объявлением.
В зависимости от местоположения анонимный класс ведет себя как статический либо как
нестатический вложенный класс - в нестатическом контексте появляется окружающий его экземпляр.

Анонимные классы имеют несколько ограничений:

• Их использование разрешено только в одном месте программы - месте его создания;
• Применение возможно только в том случае, если после порождения экземпляра нет необходимости на него ссылаться;
• Реализует лишь методы своего интерфейса или суперкласса, т.е. не может объявлять каких-либо
новых методов, так как для доступа к ним нет поименованного типа.

Анонимные классы обычно применяются для:

• создания объекта функции (function object), например, реализация интерфейса Comparator;
• создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных;
• в статическом методе генерации;
• инициализации открытого статического поля final, которое соответствует сложному перечислению типов,
когда для каждого экземпляра в перечислении требуется отдельный подкласс.

String   !!!!!!!!!!!!!!!!!!  String
Что такое «пул строк»?

Пул строк – это набор строк, хранящийся в Heap.

• Пул строк возможен благодаря неизменяемости строк в Java и реализации идеи интернирования строк;
• Пул строк помогает экономить память, но по этой же причине создание строки занимает больше времени;
• Когда для создания строки используются ", то сначала ищется строка в пуле с таким же значением, если находится,
    то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка на неё;
• При использовании оператора new создаётся новый объект String. Затем при помощи метода intern() эту строку
    можно поместить в пул или же получить из пула ссылку на другой объект String с таким же значением;
• Пул строк является примером паттерна «Приспособленец» (Flyweight).

!!!!!!!!!!!!!!!!!!!!!!!!!
Что делает метод intern() в классе String?

Метод intern() используется для сохранения строки в пуле строк или получения ссылки,
если такая строка уже находится в пуле.
!!!!!!!!!!!!!!!!!!!!!!!!!

1) абстрактный класс = что-то базовое и большое, мы должны реализовать ВСЕ абстрактные методы, это удобно когда под
этот класс попадают все или почти все сущности (например создаем машины, а в абстрактном классе есть абстрактные методы
wheels, maxSpeed, doors, color, name и все машины имеют эти аттрибуты, т.е. реализовать все абстрактные методы ЕСТЬ смысл)
2) Интерфейсы = куски описания, которые не всегда пересекаются и их можно комбинировать, например нам нужно описать
компьютер. Нет смысла все тулить в абстрактный класс, ведь компьютера бывают разные: ноутбук, домашний ПК, сервер,
compute stick. И объекты будут иметь поля: внешний блок питания (большой ПК / сервер), Адаптер питания (ноутбук,
маленький компьютер), монитор, встроенный дисплей (ноутбук), DVD-привод (у compute stick нет вообще такого) и т.д.,
то есть нет смысла все это пихать в абстрактный класс и потом при желании создать объект ноутбука переопределять
ненужные методы типо внешнего дисплея, внешнего блока питания и большого корпуса, т.к. это ноутбук и там попросту
этого нет. А вместо этого можно реализовать по отдельности интерфейсы ноутбук, домашний ПК, сервер, compute stick,
которые уже будут иметь только НУЖНЫЕ методы.

хочу уточнить и добавить: " а в абстрактном классе есть абстрактные методы wheels, maxSpeed, doors, color, name "
- это поля, а не методы. Методы обозначают действие и описываются глаголами (run, go, eat, ride etc).
Еще важная разница между абстрактными классами и интерфейсами: интерфейсы не могут иметь полей,
а абстрактные классы могут, как и любые классы. Классы как абстрактные так и нет именуются существительным
(wheels, maxSpeed, doors, color, name), а интерфейсы прилагетельными, которые указывают на умение или возможность
действия(eatable, ableToGo, runable, shotable etc)...

!!!!!!!!!!!!!!!!!!!!!!!!!!!